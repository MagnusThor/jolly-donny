/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/src/index.js":
/*!***************************!*\
  !*** ./dist/src/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultFormatter: () => (/* reexport safe */ _src_storage_formaters_DefaultFormatter__WEBPACK_IMPORTED_MODULE_11__.DefaultFormatter),\n/* harmony export */   EntityBase: () => (/* reexport safe */ _storage_entity_EntityBase__WEBPACK_IMPORTED_MODULE_6__.EntityBase),\n/* harmony export */   IndexedDBProvider: () => (/* reexport safe */ _storage_providers_IndexDBProvider__WEBPACK_IMPORTED_MODULE_4__.IndexedDBProvider),\n/* harmony export */   LocalStorageProvider: () => (/* reexport safe */ _storage_providers_LocalStorageProvider__WEBPACK_IMPORTED_MODULE_5__.LocalStorageProvider),\n/* harmony export */   OfflineEntity: () => (/* reexport safe */ _src_storage_entity_OfflineEntity__WEBPACK_IMPORTED_MODULE_9__.OfflineEntity),\n/* harmony export */   OfflineStorage: () => (/* reexport safe */ _storage_OfflineStorage__WEBPACK_IMPORTED_MODULE_8__.OfflineStorage),\n/* harmony export */   QueryableArray: () => (/* reexport safe */ _storage_QueryableArray__WEBPACK_IMPORTED_MODULE_7__.QueryableArray)\n/* harmony export */ });\n/* harmony import */ var _storage_interface_IOfflineEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage/interface/IOfflineEntity */ \"./dist/src/storage/interface/IOfflineEntity.js\");\n/* harmony import */ var _storage_interface_IOfflineStorageProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage/interface/IOfflineStorageProvider */ \"./dist/src/storage/interface/IOfflineStorageProvider.js\");\n/* harmony import */ var _storage_interface_IModelOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storage/interface/IModelOperations */ \"./dist/src/storage/interface/IModelOperations.js\");\n/* harmony import */ var _storage_interface_IOfflineGraph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage/interface/IOfflineGraph */ \"./dist/src/storage/interface/IOfflineGraph.js\");\n/* harmony import */ var _storage_providers_IndexDBProvider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage/providers/IndexDBProvider */ \"./dist/src/storage/providers/IndexDBProvider.js\");\n/* harmony import */ var _storage_providers_LocalStorageProvider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage/providers/LocalStorageProvider */ \"./dist/src/storage/providers/LocalStorageProvider.js\");\n/* harmony import */ var _storage_entity_EntityBase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./storage/entity/EntityBase */ \"./dist/src/storage/entity/EntityBase.js\");\n/* harmony import */ var _storage_QueryableArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./storage/QueryableArray */ \"./dist/src/storage/QueryableArray.js\");\n/* harmony import */ var _storage_OfflineStorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./storage/OfflineStorage */ \"./dist/src/storage/OfflineStorage.js\");\n/* harmony import */ var _src_storage_entity_OfflineEntity__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/storage/entity/OfflineEntity */ \"./dist/src/storage/entity/OfflineEntity.js\");\n/* harmony import */ var _src_storage_interface_IFormatter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/storage/interface/IFormatter */ \"./dist/src/storage/interface/IFormatter.js\");\n/* harmony import */ var _src_storage_formaters_DefaultFormatter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/storage/formaters/DefaultFormatter */ \"./dist/src/storage/formaters/DefaultFormatter.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/index.js?");

/***/ }),

/***/ "./dist/src/storage/OfflineStorage.js":
/*!********************************************!*\
  !*** ./dist/src/storage/OfflineStorage.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OfflineStorage: () => (/* binding */ OfflineStorage)\n/* harmony export */ });\n/* harmony import */ var _QueryableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./QueryableArray */ \"./dist/src/storage/QueryableArray.js\");\n\n/**\n * The `OfflineStorage` class provides a mechanism for managing offline data storage\n * with support for CRUD operations, querying, and change notifications. It utilizes\n * a storage provider implementing the `IOfflineStorageProvider` interface to handle\n * the underlying storage operations.\n *\n * ### Features:\n * - CRUD operations (`insert`, `update`, `delete`) for entities extending `EntityBase`.\n * - Querying capabilities with support for filtering and property selection.\n * - Change notifications via the `onChange` callback.\n * - Utility methods for picking and omitting properties from objects.\n * - Support for managing multiple labeled collections of entities.\n *\n * ### Example Usage:\n * ```typescript\n * const storageProvider: IOfflineStorageProvider = new MyStorageProvider();\n * const offlineStorage = new OfflineStorage(storageProvider, 'my-storage');\n *\n * await offlineStorage.init();\n *\n * const userModel = offlineStorage.getModel<User>('users');\n * await userModel.insert({ id: '1', name: 'John Doe' });\n * const users = await userModel.all();\n * console.log(users);\n * ```\n *\n * @template T - The type of entities managed by the storage, extending `EntityBase`.\n */\nclass OfflineStorage {\n    onChange;\n    storageName;\n    provider;\n    /**\n     * Creates an instance of the OfflineStorage class.\n     *\n     * @param provider - An implementation of the IOfflineStorageProvider interface used to handle storage operations.\n     * @param storageName - The name of the storage. Defaults to 'jolly-dolly' if not provided.\n     */\n    constructor(provider, storageName = 'jolly-dolly') {\n        this.storageName = storageName;\n        this.provider = provider;\n    }\n    /**\n     * Selects a subset of properties from an object based on the provided keys.\n     *\n     * @template T - The type of the object to pick properties from.\n     * @template K - The keys of the properties to pick from the object.\n     * @param model - The object from which properties will be picked.\n     * @param keys - The keys of the properties to include in the resulting object.\n     * @returns A new object containing only the specified keys and their corresponding values from the input object.\n     */\n    static pick(model, ...keys) {\n        const result = {};\n        for (const key of keys) {\n            if (key in model) {\n                result[key] = model[key];\n            }\n        }\n        return result;\n    }\n    /**\n     * Creates a shallow copy of the given object, omitting the specified keys.\n     *\n     * @template T - The type of the input object.\n     * @template K - The keys of the input object to omit.\n     * @param model - The object to copy and omit keys from.\n     * @param keys - The keys to omit from the resulting object.\n     * @returns A new object with the specified keys omitted.\n     */\n    static omit(model, ...keys) {\n        const result = { ...model };\n        for (const key of keys) {\n            delete result[key];\n        }\n        return result;\n    }\n    parseItem(label, item) {\n        if (item && typeof (item) === 'object' && 'fromJSON' in item) {\n            const temp = new (item.constructor)();\n            temp.fromJSON(item);\n            return temp;\n        }\n        return item;\n    }\n    /**\n     * Retrieves a set of model operations for a specific entity type.\n     *\n     * @template T - The type of the entity, extending `EntityBase`.\n     * @param label - A string label identifying the entity type.\n     * @returns An object implementing `IModelOperations<T>` with methods to perform CRUD operations and queries:\n     *\n     * - `insert`: Inserts a new entity of type `T`.\n     * - `update`: Updates an existing entity of type `T`.\n     * - `delete`: Deletes an entity of type `T`.\n     * - `findById`: Finds an entity by its unique identifier.\n     * - `find`: Finds entities matching a query function, optionally picking specific keys.\n     * - `all`: Retrieves all entities of type `T`.\n     * - `get`: Retrieves an entity by its index in the collection.\n     * - `toArray`: Retrieves all entities as an array.\n     */\n    getModel(label) {\n        return {\n            insert: async (item, silent) => this.insert(label, item, silent),\n            update: (item) => this.update(label, item),\n            delete: (item) => this.delete(label, item),\n            findById: (uuid) => this.findById(label, uuid),\n            find: (query, pickKeys) => this.find(label, query, pickKeys),\n            all: () => this.all(label),\n            get: async (index) => {\n                const allItems = await this.all(label);\n                return allItems[index];\n            },\n            toArray: async () => {\n                return await this.all(label);\n            },\n            updateAll: async (predicate, update) => {\n                await this.updateAll(label, predicate, update);\n            },\n            deleteMany: async (predicateOrItems) => {\n                await this.deleteMany(label, predicateOrItems);\n            },\n        };\n    }\n    /**\n     * Adds a new model to the offline storage with the specified label.\n     *\n     * @template T - The type of the entities that the model will manage, extending `EntityBase`.\n     * @param label - The label used to identify the new model.\n     * @returns A promise that resolves to the newly created offline graph model.\n     */\n    async addModel(label) {\n        const newModel = { label: label, collection: [] };\n        this.provider.addModel(label, newModel);\n        return newModel;\n    }\n    /**\n     * Saves the current state of the storage using the underlying provider.\n     * If an `onChange` callback is defined, it will be invoked after the save operation\n     * with details about the storage name and the origin of the change.\n     *\n     * @returns A promise that resolves when the save operation is complete.\n     */\n    async save() {\n        await this.provider.save();\n        if (this.onChange)\n            this.onChange({ label: this.storageName, origin: 'save' });\n    }\n    /**\n     * Inserts an item into the storage under the specified label.\n     * Optionally triggers a change event unless silenced.\n     *\n     * @template T - The type of the entity being inserted, extending `EntityBase`.\n     * @param label - The label under which the item will be stored.\n     * @param item - The item to be inserted into the storage.\n     * @param silent - Optional flag to suppress the `onChange` event if set to `true`.\n     * @returns A promise that resolves to the inserted item.\n     */\n    async insert(label, item, silent) {\n        await this.provider.update(label, item);\n        if (this.onChange && !silent)\n            this.onChange({ label, origin: 'insert', item });\n        return item;\n    }\n    /**\n     * Updates an item in the storage with the specified label.\n     *\n     * @template T - The type of the entity being updated, extending `EntityBase`.\n     * @param label - A string representing the label or key associated with the item.\n     * @param item - The item of type `T` to be updated in the storage.\n     * @returns A promise that resolves when the update operation is complete.\n     *\n     * @remarks\n     * This method also triggers the `onChange` callback, if defined,\n     * with details about the update operation, including the label,\n     * origin of the change, and the updated item.\n     */\n    async update(label, item) {\n        await this.provider.update(label, item);\n        if (this.onChange)\n            this.onChange({ label, origin: 'update', item });\n    }\n    /**\n     * Updates all items of a specific type in the storage that match a given predicate.\n     *\n     * @template T - The type of the entities being updated, extending `EntityBase`.\n     * @param label - A string label used to identify the collection of items.\n     * @param predicate - A function that determines whether an item should be updated.\n     *                     It receives an item of type `T` and returns a boolean.\n     * @param update - A function that performs the update on an item of type `T`.\n     *                 It modifies the item in place.\n     * @returns A promise that resolves when all matching items have been updated.\n     */\n    async updateAll(label, predicate, update) {\n        const items = await this.all(label);\n        for (const item of items) {\n            if (predicate(item)) {\n                update(item);\n                await this.update(label, item);\n            }\n        }\n    }\n    /**\n     * Deletes an item of type `T` associated with the specified label from the storage.\n     *\n     * @template T - The type of the entity to be deleted, extending `EntityBase`.\n     * @param label - A string representing the label or key associated with the item.\n     * @param item - The item of type `T` to be deleted.\n     * @returns A promise that resolves when the deletion is complete.\n     *\n     * @remarks\n     * If an `onChange` callback is defined, it will be invoked after the deletion\n     * with details about the operation, including the label, origin, and the deleted item.\n     */\n    async delete(label, item) {\n        await this.provider.delete(label, item);\n        if (this.onChange)\n            this.onChange({ label, origin: 'delete', item });\n    }\n    /**\n     * Deletes multiple items from storage based on a label and either a predicate function\n     * or an array of items to delete.\n     *\n     * @template T - The type of the entities extending `EntityBase`.\n     * @param label - The label identifying the storage collection.\n     * @param predicateOrItems - Either a predicate function to filter items for deletion\n     * or an array of items to delete directly.\n     *\n     * If a predicate function is provided, all items in the storage collection matching\n     * the predicate will be deleted. If an array of items is provided, each item in the\n     * array will be deleted.\n     *\n     * @returns A promise that resolves when the deletion process is complete.\n     */\n    async deleteMany(label, predicateOrItems) {\n        if (Array.isArray(predicateOrItems)) {\n            // Delete by items array\n            for (const item of predicateOrItems) {\n                await this.delete(label, item);\n            }\n        }\n        else {\n            // Delete by predicate\n            const items = await this.all(label);\n            for (const item of items) {\n                if (predicateOrItems(item)) {\n                    await this.delete(label, item);\n                }\n            }\n        }\n    }\n    /**\n     * Retrieves an entity of type `T` by its unique identifier (UUID) from the storage.\n     *\n     * @template T - The type of the entity that extends `EntityBase`.\n     * @param label - A string representing the label or category of the entity.\n     * @param uuid - The unique identifier of the entity to retrieve.\n     * @returns A promise that resolves to the entity of type `T` if found, or `undefined` if not found.\n     */\n    async findById(label, uuid) {\n        const item = await this.provider.findById(label, uuid);\n        if (!item)\n            return undefined;\n        return this.parseItem(label, item);\n    }\n    /**\n     * Finds and retrieves items from the storage based on the specified label and query function.\n     * Optionally, specific keys can be picked from the retrieved items.\n     *\n     * @template T - The type of the entity being queried, extending `EntityBase`.\n     * @template K - The keys of the entity type `T` that can be picked, defaults to all keys of `T`.\n     *\n     * @param label - A string label used to identify the collection or group of items in the storage.\n     * @param query - A function that takes an item of type `T` and returns a boolean indicating\n     *                whether the item matches the query criteria.\n     * @param pickKeys - An optional array of keys of type `K` to specify which properties of the\n     *                   items should be included in the result. If not provided, all properties\n     *                   are included.\n     *\n     * @returns A promise that resolves to a `QueryableArray` containing the items of type `T`\n     *          that match the query, with only the specified keys if `pickKeys` is provided.\n     */\n    async find(label, query, pickKeys) {\n        const items = await this.provider.find(label, query, pickKeys);\n        return new _QueryableArray__WEBPACK_IMPORTED_MODULE_0__.QueryableArray(...items.map(item => this.parseItem(label, item)));\n    }\n    /**\n     * Retrieves all entities of a specified type from the storage provider.\n     *\n     * @template T - The type of entities to retrieve, extending `EntityBase`.\n     * @param {Object} params - The parameters for the query.\n     * @param {string} params.label - The label identifying the type of entities to retrieve.\n     * @returns {Promise<Array<T>>} A promise that resolves to a `QueryableArray` containing the retrieved entities.\n     */\n    async all(label) {\n        try {\n            const items = await this.provider.all(label);\n            const parsedItems = items.map(item => {\n                const parsedItem = this.parseItem(label, item);\n                if (!parsedItem) {\n                    console.warn(`Failed to parse item for label ${label}:`, item);\n                    return null;\n                }\n                return parsedItem;\n            }).filter(item => item !== null);\n            return new _QueryableArray__WEBPACK_IMPORTED_MODULE_0__.QueryableArray(...parsedItems);\n        }\n        catch (error) {\n            console.error(`Error retrieving all items for label ${label}:`, error);\n            return new _QueryableArray__WEBPACK_IMPORTED_MODULE_0__.QueryableArray(); // Or throw an error, depending on your error-handling strategy\n        }\n    }\n    /**\n     * Initializes the offline storage provider with the specified storage name.\n     * This method ensures that the storage provider is ready for use.\n     *\n     * @returns A promise that resolves when the initialization is successful,\n     *          or rejects with an error if the initialization fails.\n     */\n    init() {\n        return new Promise(async (resolve, reject) => {\n            try {\n                await this.provider.init(this.storageName);\n                resolve();\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/OfflineStorage.js?");

/***/ }),

/***/ "./dist/src/storage/QueryableArray.js":
/*!********************************************!*\
  !*** ./dist/src/storage/QueryableArray.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryableArray: () => (/* binding */ QueryableArray)\n/* harmony export */ });\n/**\n * A custom array class that provides additional query-like methods for filtering, mapping, and manipulating arrays.\n * @template T - The type of elements in the array.\n */\nclass QueryableArray extends Array {\n    /**\n     * Skips the specified number of elements and returns the remaining elements.\n     * @param count - The number of elements to skip.\n     * @returns A new QueryableArray containing the remaining elements.\n     */\n    skip(count) {\n        const result = new QueryableArray(...this.slice(count));\n        return result;\n    }\n    /**\n     * Takes the specified number of elements from the start of the array.\n     * @param count - The number of elements to take.\n     * @returns A new QueryableArray containing the taken elements.\n     */\n    take(count) {\n        const result = new QueryableArray(...this.slice(0, count));\n        return result;\n    }\n    /**\n     * Filters the array based on a predicate function.\n     * @param predicate - A function to test each element.\n     * @returns A new QueryableArray containing the elements that satisfy the predicate.\n     */\n    where(predicate) {\n        const result = new QueryableArray(...this.filter(predicate));\n        return result;\n    }\n    /**\n     * Projects each element of the array into a new form.\n     * @template U - The type of the projected elements.\n     * @param selector - A function to transform each element.\n     * @returns A new QueryableArray containing the transformed elements.\n     */\n    select(selector) {\n        const result = new QueryableArray(...this.map(selector));\n        return result;\n    }\n    /**\n     * Returns the first element that satisfies the predicate or the first element if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The first matching element.\n     * @throws An error if no matching element is found.\n     */\n    first(predicate) {\n        const item = predicate ? this.find(predicate) : this[0];\n        if (item === undefined) {\n            throw new Error('Sequence contains no matching element');\n        }\n        return item;\n    }\n    /**\n     * Returns the first element that satisfies the predicate or undefined if no matching element is found.\n     * @param predicate - A function to test each element (optional).\n     * @returns The first matching element or undefined.\n     */\n    firstOrDefault(predicate) {\n        return predicate ? this.find(predicate) : this[0];\n    }\n    /**\n     * Returns the last element that satisfies the predicate or the last element if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The last matching element.\n     * @throws An error if no matching element is found.\n     */\n    last(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        if (items.length === 0) {\n            throw new Error('Sequence contains no matching element');\n        }\n        return items[items.length - 1];\n    }\n    /**\n     * Returns the last element that satisfies the predicate or undefined if no matching element is found.\n     * @param predicate - A function to test each element (optional).\n     * @returns The last matching element or undefined.\n     */\n    lastOrDefault(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        return items.length > 0 ? items[items.length - 1] : undefined;\n    }\n    /**\n     * Returns the only element that satisfies the predicate or the only element if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The single matching element.\n     * @throws An error if there is not exactly one matching element.\n     */\n    single(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        if (items.length !== 1) {\n            throw new Error('Sequence contains more than one matching element');\n        }\n        return items[0];\n    }\n    /**\n     * Returns the only element that satisfies the predicate or undefined if no matching element is found.\n     * @param predicate - A function to test each element (optional).\n     * @returns The single matching element or undefined.\n     */\n    singleOrDefault(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        return items.length === 1 ? items[0] : undefined;\n    }\n    /**\n     * Determines whether any elements satisfy the predicate or whether the array contains any elements if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns True if any elements satisfy the predicate or if the array contains any elements.\n     */\n    any(predicate) {\n        return predicate ? this.some(predicate) : this.length > 0;\n    }\n    /**\n     * Determines whether all elements satisfy the predicate.\n     * @param predicate - A function to test each element.\n     * @returns True if all elements satisfy the predicate.\n     */\n    all(predicate) {\n        return this.every(predicate);\n    }\n    /**\n     * Counts the number of elements that satisfy the predicate or the total number of elements if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The count of matching elements.\n     */\n    count(predicate) {\n        return predicate ? this.filter(predicate).length : this.length;\n    }\n    /**\n     * Sorts the elements in ascending order based on a key.\n     * @template K - The type of the key.\n     * @param keySelector - A function to extract the key for each element.\n     * @returns A new QueryableArray containing the sorted elements.\n     */\n    orderBy(keySelector) {\n        const result = new QueryableArray(...this.sort((a, b) => {\n            if (keySelector(a) < keySelector(b))\n                return -1;\n            if (keySelector(a) > keySelector(b))\n                return 1;\n            return 0;\n        }));\n        return result;\n    }\n    /**\n     * Sorts the elements in descending order based on a key.\n     * @template K - The type of the key.\n     * @param keySelector - A function to extract the key for each element.\n     * @returns A new QueryableArray containing the sorted elements.\n     */\n    orderByDescending(keySelector) {\n        const result = new QueryableArray(...this.sort((a, b) => {\n            if (keySelector(a) > keySelector(b))\n                return -1;\n            if (keySelector(a) < keySelector(b))\n                return 1;\n            return 0;\n        }));\n        return result;\n    }\n    /**\n     * Groups the elements of the array based on a key.\n     * @template K - The type of the key.\n     * @param keySelector - A function to extract the key for each element.\n     * @returns A Map where the keys are the group keys and the values are QueryableArrays of grouped elements.\n     */\n    groupBy(keySelector) {\n        const map = new Map();\n        this.forEach(item => {\n            const key = keySelector(item);\n            if (!map.has(key)) {\n                map.set(key, new QueryableArray());\n            }\n            map.get(key).push(item);\n        });\n        return map;\n    }\n    /**\n     * Removes duplicate elements from the array.\n     * @returns A new QueryableArray containing only distinct elements.\n     */\n    distinct() {\n        const set = new Set(this);\n        return new QueryableArray(...set);\n    }\n}\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/QueryableArray.js?");

/***/ }),

/***/ "./dist/src/storage/entity/EntityBase.js":
/*!***********************************************!*\
  !*** ./dist/src/storage/entity/EntityBase.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EntityBase: () => (/* binding */ EntityBase)\n/* harmony export */ });\n/**\n * Represents the base class for entities, providing common properties and functionality\n * for offline entities.\n *\n * @implements {IOfflineEntity}\n */\nclass EntityBase {\n    id;\n    created;\n    lastModified;\n    constructor() {\n        this.id = crypto.randomUUID();\n        this.created = Date.now();\n        this.lastModified = Date.now();\n    }\n}\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/entity/EntityBase.js?");

/***/ }),

/***/ "./dist/src/storage/entity/OfflineEntity.js":
/*!**************************************************!*\
  !*** ./dist/src/storage/entity/OfflineEntity.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OfflineEntity: () => (/* binding */ OfflineEntity)\n/* harmony export */ });\n/* harmony import */ var _formaters_DefaultFormatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../formaters/DefaultFormatter */ \"./dist/src/storage/formaters/DefaultFormatter.js\");\n/* harmony import */ var _EntityBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EntityBase */ \"./dist/src/storage/entity/EntityBase.js\");\n\n\nclass OfflineEntity extends _EntityBase__WEBPACK_IMPORTED_MODULE_1__.EntityBase {\n    modelDefinition;\n    constructor(definition) {\n        super();\n        this.modelDefinition = definition;\n    }\n    format(key, value) {\n        if (this.modelDefinition && this.modelDefinition.formatters && this.modelDefinition.formatters[key]) {\n            return this.modelDefinition.formatters[key].format(value);\n        }\n        return new _formaters_DefaultFormatter__WEBPACK_IMPORTED_MODULE_0__.DefaultFormatter().format(value);\n    }\n    parse(key, value) {\n        if (this.modelDefinition && this.modelDefinition.formatters && this.modelDefinition.formatters[key]) {\n            return this.modelDefinition.formatters[key].parse(value);\n        }\n        return new _formaters_DefaultFormatter__WEBPACK_IMPORTED_MODULE_0__.DefaultFormatter().parse(value);\n    }\n    toJSON() {\n        const json = { ...this };\n        if (this.modelDefinition && this.modelDefinition.formatters) {\n            for (const key in this.modelDefinition.formatters) {\n                if (this.hasOwnProperty(key)) {\n                    json[key] = this.format(key, this[key]);\n                }\n            }\n        }\n        return json;\n    }\n    fromJSON(json) {\n        for (const key in json) {\n            if (this.hasOwnProperty(key)) {\n                if (this.modelDefinition?.formatters && key in this.modelDefinition.formatters) {\n                    this[key] = this.parse(key, json[key]);\n                }\n                else {\n                    // Handle properties without formatters\n                    if (json[key] !== undefined) {\n                        this[key] = json[key];\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/entity/OfflineEntity.js?");

/***/ }),

/***/ "./dist/src/storage/formaters/DefaultFormatter.js":
/*!********************************************************!*\
  !*** ./dist/src/storage/formaters/DefaultFormatter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultFormatter: () => (/* binding */ DefaultFormatter)\n/* harmony export */ });\nclass DefaultFormatter {\n    format(value) {\n        console.log('DefaultFormatter format', value);\n        return value;\n    }\n    parse(value) {\n        console.log('DefaultFormatter parse', value);\n        return value;\n    }\n}\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/formaters/DefaultFormatter.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IFormatter.js":
/*!**************************************************!*\
  !*** ./dist/src/storage/interface/IFormatter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IFormatter.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IModelOperations.js":
/*!********************************************************!*\
  !*** ./dist/src/storage/interface/IModelOperations.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IModelOperations.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IOfflineEntity.js":
/*!******************************************************!*\
  !*** ./dist/src/storage/interface/IOfflineEntity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IOfflineEntity.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IOfflineGraph.js":
/*!*****************************************************!*\
  !*** ./dist/src/storage/interface/IOfflineGraph.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IOfflineGraph.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IOfflineStorageProvider.js":
/*!***************************************************************!*\
  !*** ./dist/src/storage/interface/IOfflineStorageProvider.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IOfflineStorageProvider.js?");

/***/ }),

/***/ "./dist/src/storage/providers/IndexDBProvider.js":
/*!*******************************************************!*\
  !*** ./dist/src/storage/providers/IndexDBProvider.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IndexedDBProvider: () => (/* binding */ IndexedDBProvider)\n/* harmony export */ });\nclass IndexedDBProvider {\n    dbPromise = null;\n    storageName;\n    version;\n    constructor(version = 1) {\n        this.version = version;\n    }\n    addModel(label, model) {\n        throw new Error('No need to add models to IndexedDB provider');\n    }\n    async init(storageName) {\n        this.storageName = storageName;\n        this.dbPromise = this.openDatabase();\n        await this.dbPromise; // Ensure db is open before proceeding\n    }\n    openDatabase() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.storageName, this.version);\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                if (!db.objectStoreNames.contains('data')) {\n                    db.createObjectStore('data', { keyPath: 'id' });\n                }\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n            request.onerror = (event) => {\n                reject(event.target.error);\n            };\n        });\n    }\n    async getObjectStore(mode) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction('data', mode);\n        return transaction.objectStore('data');\n    }\n    async save() {\n        // IndexedDB handles saving automatically.\n    }\n    async update(label, item) {\n        const store = await this.getObjectStore('readwrite');\n        const data = await store.get(item.id);\n        if (data) {\n            await store.put(item);\n        }\n        else {\n            await store.add(item);\n        }\n    }\n    async delete(label, item) {\n        const store = await this.getObjectStore('readwrite');\n        await store.delete(item.id);\n    }\n    async findById(label, uuid) {\n        const store = await this.getObjectStore('readonly');\n        return new Promise((resolve, reject) => {\n            const request = store.get(uuid);\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(request.error);\n            };\n        });\n    }\n    async find(label, query, pickKeys) {\n        const store = await this.getObjectStore('readonly');\n        const allItems = await new Promise((resolve, reject) => {\n            const request = store.getAll();\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n        const filteredItems = allItems.filter(query);\n        if (pickKeys) {\n            return filteredItems.map((item) => {\n                const result = {};\n                pickKeys.forEach((key) => {\n                    if (key in item) {\n                        result[key] = item[key];\n                    }\n                });\n                return result;\n            });\n        }\n        else {\n            return filteredItems;\n        }\n    }\n    async all(label) {\n        const store = await this.getObjectStore('readonly');\n        return new Promise((resolve, reject) => {\n            const request = store.getAll();\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(request.error);\n            };\n        });\n    }\n    async getModels() {\n        return Promise.resolve(new Map()); // IndexedDB does not use in-memory models\n    }\n}\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/providers/IndexDBProvider.js?");

/***/ }),

/***/ "./dist/src/storage/providers/LocalStorageProvider.js":
/*!************************************************************!*\
  !*** ./dist/src/storage/providers/LocalStorageProvider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalStorageProvider: () => (/* binding */ LocalStorageProvider)\n/* harmony export */ });\nclass LocalStorageProvider {\n    models = new Map();\n    storageName;\n    async init(storageName) {\n        this.storageName = storageName;\n        await this.deSerialize();\n    }\n    async save() {\n        return new Promise((resolve) => {\n            const data = this.serialize();\n            localStorage.setItem(this.storageName, data);\n            resolve();\n        });\n    }\n    async update(label, item) {\n        const model = this.models.get(label);\n        if (model) {\n            const index = model.collection.findIndex((pre) => pre.id === item.id);\n            if (index !== -1) {\n                item.lastModified = Date.now();\n                model.collection[index] = item;\n            }\n            else {\n                model.collection.push(item);\n            }\n        }\n        await this.save();\n    }\n    async delete(label, item) {\n        const model = this.models.get(label);\n        if (model) {\n            const index = model.collection.findIndex((pre) => pre.id === item.id);\n            if (index !== -1) {\n                model.collection.splice(index, 1);\n            }\n        }\n        await this.save();\n    }\n    async findById(label, uuid) {\n        const model = this.models.get(label);\n        if (model) {\n            return model.collection.find((pre) => pre.id === uuid);\n        }\n        return undefined;\n    }\n    async find(label, query, pickKeys) {\n        const model = this.models.get(label);\n        if (!model) {\n            return [];\n        }\n        const filteredItems = model.collection.filter(query);\n        if (pickKeys) {\n            return filteredItems.map((item) => {\n                const result = {};\n                pickKeys.forEach((key) => {\n                    if (key in item) {\n                        result[key] = item[key];\n                    }\n                });\n                return result;\n            });\n        }\n        else {\n            return filteredItems;\n        }\n    }\n    async all(label) {\n        const model = this.models.get(label);\n        if (model) {\n            return model.collection;\n        }\n        return [];\n    }\n    async getModels() {\n        return Promise.resolve(this.models);\n    }\n    addModel(label, model) {\n        this.models.set(label, model);\n    }\n    serialize() {\n        return JSON.stringify(Array.from(this.models.entries()));\n    }\n    async deSerialize() {\n        return new Promise((resolve, reject) => {\n            const data = localStorage.getItem(this.storageName);\n            if (!data) {\n                reject(new Error('No data found'));\n                return;\n            }\n            try {\n                const parsedData = JSON.parse(data);\n                this.models = new Map(parsedData);\n                resolve();\n            }\n            catch (e) {\n                reject(new Error('Error parsing data'));\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/providers/LocalStorageProvider.js?");

/***/ }),

/***/ "./dist/test/test.js":
/*!***************************!*\
  !*** ./dist/test/test.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TestClint: () => (/* binding */ TestClint)\n/* harmony export */ });\n/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/index */ \"./dist/src/index.js\");\n/* harmony import */ var _src_storage_entity_OfflineEntity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/storage/entity/OfflineEntity */ \"./dist/src/storage/entity/OfflineEntity.js\");\n\n\nclass CustomStringFormater {\n    format(value) {\n        return value.toLowerCase(); // always store the value in lower case\n    }\n    parse(value) {\n        return value.toUpperCase(); // always return the value in upper case\n    }\n}\nclass CustomDateFormater {\n    format(value) {\n        // Store the Date object as is\n        return value;\n    }\n    parse(value) {\n        if (!value) {\n            return null;\n        }\n        value.setHours(0, 0, 0, 0); // set the time to 00:00:00.000\n        return value;\n    }\n}\nclass User extends _src_storage_entity_OfflineEntity__WEBPACK_IMPORTED_MODULE_1__.OfflineEntity {\n    id;\n    created;\n    lastModified;\n    name;\n    age;\n    birthDate = null;\n    constructor(name, age) {\n        super({\n            formatters: {\n                name: new CustomStringFormater(),\n                birthDate: new CustomDateFormater(),\n            },\n        });\n        this.id = crypto.randomUUID();\n        this.created = Date.now();\n        this.lastModified = Date.now();\n        this.name = name;\n        this.age = age;\n        this.birthDate = new Date();\n    }\n}\nclass TestClint {\n    storage;\n    async setup() {\n    }\n    async runCommans() {\n        this.storage.getModel(\"users\").toArray().then((users) => {\n            users.forEach((user) => {\n                console.log(user);\n            });\n            //  storage.deleteMany(\"users\", users); \n            // users.forEach((user) => {\n            //     storage.delete(\"users\", user);\n            // });\n        });\n        const mewUser = new User('Magnus', Math.floor(Math.random() * 100));\n        this.storage.insert('users', mewUser);\n        const retrievedUser = await this.storage.getModel('users').findById(mewUser.id);\n        if (retrievedUser) {\n            console.log('Retrieved user:', retrievedUser);\n            console.log('Retrieved user name:', retrievedUser.name); // Should be \"JOHN DOE\"\n        }\n    }\n    constructor() {\n        //const provider = new LocalStorageProvider();\n        const provider = new _src_index__WEBPACK_IMPORTED_MODULE_0__.IndexedDBProvider;\n        this.storage = new _src_index__WEBPACK_IMPORTED_MODULE_0__.OfflineStorage(provider, 'testStorage');\n        this.storage.init().then(async () => {\n            console.log('Storage initialized');\n            await this.runCommans();\n        }).catch(async () => {\n            this.storage.addModel('users');\n            this.storage.save();\n            await this.runCommans();\n        });\n        // if(!storage.getModel('users')){\n        //     storage.addModel('users');      \n        // }\n        //  const user = new User('John Doe', 25);\n        //  storage.insert(\"users\",user);\n        //  storage.save();\n    }\n    async test() {\n        return true;\n    }\n}\ndocument.addEventListener('DOMContentLoaded', () => {\n    const testApp = new TestClint();\n    testApp.test();\n});\n\n\n//# sourceURL=webpack://jolly-donny/./dist/test/test.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/test/test.js");
/******/ 	
/******/ })()
;