/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/src/index.js":
/*!***************************!*\
  !*** ./dist/src/index.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./storage/interface/IPersistedEntity  */ \"./dist/src/storage/interface/IPersistedEntity .js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/interface/IOfflineStorageProvider */ \"./dist/src/storage/interface/IOfflineStorageProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/interface/ICollectionOperations */ \"./dist/src/storage/interface/ICollectionOperations.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/interface/ICollection */ \"./dist/src/storage/interface/ICollection.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/interface/IOfflineStorageProvider */ \"./dist/src/storage/interface/IOfflineStorageProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/providers/IndexDBProvider */ \"./dist/src/storage/providers/IndexDBProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/providers/LocalStorageProvider */ \"./dist/src/storage/providers/LocalStorageProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/entity/PersistedEntityBase */ \"./dist/src/storage/entity/PersistedEntityBase.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/utils/QueryableArray */ \"./dist/src/storage/utils/QueryableArray.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/OfflineStorage */ \"./dist/src/storage/OfflineStorage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/entity/PersistedEntity */ \"./dist/src/storage/entity/PersistedEntity.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/interface/IFormatter */ \"./dist/src/storage/interface/IFormatter.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/formaters/DefaultFormatter */ \"./dist/src/storage/formaters/DefaultFormatter.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/entity/PersistedEntityBuilder */ \"./dist/src/storage/entity/PersistedEntityBuilder.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/interface/IEntityDefinition */ \"./dist/src/storage/interface/IEntityDefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/interface/IInterceptor */ \"./dist/src/storage/interface/IInterceptor.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/interface/IProviderConfig */ \"./dist/src/storage/interface/IProviderConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/interface/IWebApiConfig */ \"./dist/src/storage/interface/IWebApiConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ../src/storage/interceptors/WebApiInterceptor */ \"./dist/src/storage/interceptors/WebApiInterceptor.js\"), exports);\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/index.js?");

/***/ }),

/***/ "./dist/src/storage/OfflineStorage.js":
/*!********************************************!*\
  !*** ./dist/src/storage/OfflineStorage.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OfflineStorage = void 0;\nconst QueryableArray_1 = __webpack_require__(/*! ./utils/QueryableArray */ \"./dist/src/storage/utils/QueryableArray.js\");\n/**\n * The `OfflineStorage` class provides a mechanism for managing offline storage of entities.\n * It supports CRUD operations, querying, and advanced manipulation of stored data.\n * The class is designed to work with a storage provider implementing the `IOfflineStorageProvider` interface.\n *\n * @template T - The type of entities managed by the storage, extending `EntityBase`.\n *\n * @remarks\n * - The class includes utility methods for selecting (`pick`) and omitting (`omit`) properties from objects.\n * - It supports advanced querying capabilities through `QueryableArray`.\n * - The `onChange` callback can be used to track changes in the storage.\n *\n * @example\n * ```typescript\n * const provider: IOfflineStorageProvider = new MyStorageProvider();\n * const storage = new OfflineStorage(provider, 'my-storage');\n *\n * await storage.init();\n *\n * const userCollection = storage.getCollection<User>('users');\n * await userCollection.insert({ id: '1', name: 'John Doe' });\n * const users = await userCollection.all();\n * console.log(users);\n * ```\n */\nclass OfflineStorage {\n    onChange;\n    storageName;\n    provider;\n    /**\n     * Creates an instance of the OfflineStorage class.\n     *\n     * @param provider - An implementation of the IOfflineStorageProvider interface used to handle storage operations.\n     * @param storageName - The name of the storage. Defaults to 'jolly-dolly' if not provided.\n     */\n    constructor(provider, storageName = 'jolly-dolly') {\n        this.storageName = storageName;\n        this.provider = provider;\n    }\n    /**\n     * Selects a subset of properties from an object based on the provided keys.\n     *\n     * @template T - The type of the object to pick properties from.\n     * @template K - The keys of the properties to pick from the object.\n     * @param object - The object from which properties will be picked.\n     * @param keys - The keys of the properties to include in the resulting object.\n     * @returns A new object containing only the specified keys and their corresponding values from the input object.\n     */\n    static pick(object, ...keys) {\n        const result = {};\n        for (const key of keys) {\n            if (key in object) {\n                result[key] = object[key];\n            }\n        }\n        return result;\n    }\n    /**\n * Fetches data from a given URL and optionally applies a transformation function.\n * Supports request timeout and abort functionality.\n *\n * @template T - The type of the data returned by the fetch request.\n * @template A - The type of the data after applying the transformation function.\n *\n * @param {string} url - The URL to fetch data from.\n * @param {((result: T) => A) | undefined} [transformationFunc] - Optional function to transform the fetched data.\n * @param {RequestInit} [options] - Optional configuration for the fetch request.\n * @param {number} [timeout=5000] - The timeout duration in milliseconds before the request is aborted.\n *\n * @returns {Promise<A | T>} A promise that resolves to the transformed data or the original data if no transformation is needed.\n *\n * @throws {Error} Throws an error if the fetch request fails or if the response status is not OK.\n */\n    static async fetch(url, transformationFunc, options, timeout = 5000) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        try {\n            const response = await fetch(url, { ...options, signal: controller.signal });\n            clearTimeout(id);\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            return await transformationFunc(await response.json());\n        }\n        catch (error) {\n            console.error('Fetch error:', error);\n            throw error;\n        }\n    }\n    /**\n     * Creates a shallow copy of the given object, omitting the specified keys.\n     *\n     * @template T - The type of the input object.\n     * @template K - The keys of the input object to omit.\n     * @param object - The object to copy and omit keys from.\n     * @param keys - The keys to omit from the resulting object.\n     * @returns A new object with the specified keys omitted.\n     */\n    static omit(object, ...keys) {\n        const result = { ...object };\n        for (const key of keys) {\n            delete result[key];\n        }\n        return result;\n    }\n    /**\n     * Parses an item and attempts to reconstruct it as an instance of a class\n     * that extends `EntityBase`. If the item is an object and contains a\n     * `fromJSON` method, it creates a new instance of the item's constructor,\n     * invokes `fromJSON` to populate it, and returns the reconstructed instance.\n     * Otherwise, it casts the item to the specified type `T`.\n     *\n     * @template T - A type that extends `EntityBase`.\n     * @param label - A string label associated with the item (not used in the method logic).\n     * @param item - The item to be parsed, which may be an object with a `fromJSON` method.\n     * @returns The parsed item as an instance of type `T`, or the item cast to type `T` if parsing is not applicable.\n     */\n    parseItem(label, item) {\n        if (item && typeof (item) === 'object' && 'fromJSON' in item) {\n            const temp = new (item.constructor)();\n            temp.fromJSON(item);\n            return temp;\n        }\n        return item;\n    }\n    /**\n     * Retrieves a set of collection operations for a specific entity type.\n     *\n     * @template T - The type of the entity, extending `EntityBase`.\n     * @param label - A string label identifying the entity type.\n     * @returns An object implementing `IModelOperations<T>` with methods to perform CRUD operations and queries:\n     *\n     * - `insert`: Inserts a new entity of type `T`.\n     * - `update`: Updates an existing entity of type `T`.\n     * - `delete`: Deletes an entity of type `T`.\n     * - `findById`: Finds an entity by its unique identifier.\n     * - `find`: Finds entities matching a query function, optionally picking specific keys.\n     * - `all`: Retrieves all entities of type `T`.\n     * - `get`: Retrieves an entity by its index in the collection.\n     * - `toArray`: Retrieves all entities as an array.\n     */\n    getCollection(label) {\n        return {\n            insert: async (item, silent) => this.insert(label, item, silent),\n            update: (item) => this.update(label, item),\n            delete: (item) => this.delete(label, item),\n            findById: (uuid) => this.findById(label, uuid),\n            find: (query, pickKeys) => this.find(label, query, pickKeys),\n            all: () => this.all(label),\n            get: async (index) => {\n                const allItems = await this.all(label);\n                return allItems[index];\n            },\n            toArray: async () => {\n                return await this.all(label);\n            },\n            updateAll: async (predicate, update) => {\n                await this.updateAll(label, predicate, update);\n            },\n            deleteMany: async (predicateOrItems) => {\n                await this.deleteMany(label, predicateOrItems);\n            },\n        };\n    }\n    async toArray(label) {\n        const results = await this.provider.all(label);\n        return results;\n    }\n    /**\n     * Adds a new collection to the offline storage with the specified label.\n     *\n     * @template T - The type of the entities that the collection will manage, extending `EntityBase`.\n     * @param label - The label used to identify the new collection.\n     * @returns A promise that resolves to the newly created offline graph model.\n     */\n    async addCollection(label) {\n        const collection = { label: label, collection: [] };\n        this.provider.addCollection(label, collection);\n        return collection;\n    }\n    /**\n     * Saves the current state of the storage using the underlying provider.\n     * If an `onChange` callback is defined, it will be invoked after the save operation\n     * with details about the storage name and the origin of the change.\n     *\n     * @returns A promise that resolves when the save operation is complete.\n     */\n    async save() {\n        await this.provider.save();\n        if (this.onChange)\n            this.onChange({ label: this.storageName, origin: 'save' });\n    }\n    /**\n     * Inserts an item into the storage under the specified label.\n     * Optionally triggers a change event unless silenced.\n     *\n     * @template T - The type of the entity being inserted, extending `EntityBase`.\n     * @param label - The label under which the item will be stored.\n     * @param item - The item to be inserted into the storage.\n     * @param silent - Optional flag to suppress the `onChange` event if set to `true`.\n     * @returns A promise that resolves to the inserted item.\n     */\n    async insert(label, item, silent) {\n        await this.provider.update(label, item);\n        if (this.onChange && !silent)\n            this.onChange({ label, origin: 'insert', item });\n        return item;\n    }\n    /**\n     * Updates an item in the storage with the specified label.\n     *\n     * @template T - The type of the entity being updated, extending `EntityBase`.\n     * @param label - A string representing the label or key associated with the item.\n     * @param item - The item of type `T` to be updated in the storage.\n     * @returns A promise that resolves when the update operation is complete.\n     *\n     * @remarks\n     * This method also triggers the `onChange` callback, if defined,\n     * with details about the update operation, including the label,\n     * origin of the change, and the updated item.\n     */\n    async update(label, item) {\n        await this.provider.update(label, item);\n        if (this.onChange)\n            this.onChange({ label, origin: 'update', item });\n    }\n    /**\n     * Updates all items of a specific type in the storage that match a given predicate.\n     *\n     * @template T - The type of the entities being updated, extending `EntityBase`.\n     * @param label - A string label used to identify the collection of items.\n     * @param predicate - A function that determines whether an item should be updated.\n     *                     It receives an item of type `T` and returns a boolean.\n     * @param update - A function that performs the update on an item of type `T`.\n     *                 It modifies the item in place.\n     * @returns A promise that resolves when all matching items have been updated.\n     */\n    async updateAll(label, predicate, update) {\n        const items = await this.all(label);\n        for (const item of items) {\n            if (predicate(item)) {\n                update(item);\n                await this.update(label, item);\n            }\n        }\n    }\n    /**\n     * Deletes an item of type `T` associated with the specified label from the storage.\n     *\n     * @template T - The type of the entity to be deleted, extending `EntityBase`.\n     * @param label - A string representing the label or key associated with the item.\n     * @param item - The item of type `T` to be deleted.\n     * @returns A promise that resolves when the deletion is complete.\n     *\n     * @remarks\n     * If an `onChange` callback is defined, it will be invoked after the deletion\n     * with details about the operation, including the label, origin, and the deleted item.\n     */\n    async delete(label, item) {\n        await this.provider.delete(label, item);\n        if (this.onChange)\n            this.onChange({ label, origin: 'delete', item });\n    }\n    /**\n     * Deletes multiple items from storage based on a label and either a predicate function\n     * or an array of items to delete.\n     *\n     * @template T - The type of the entities extending `EntityBase`.\n     * @param label - The label identifying the storage collection.\n     * @param predicateOrItems - Either a predicate function to filter items for deletion\n     * or an array of items to delete directly.\n     *\n     * If a predicate function is provided, all items in the storage collection matching\n     * the predicate will be deleted. If an array of items is provided, each item in the\n     * array will be deleted.\n     *\n     * @returns A promise that resolves when the deletion process is complete.\n     */\n    async deleteMany(label, predicateOrItems) {\n        if (Array.isArray(predicateOrItems)) {\n            // Delete by items array\n            for (const item of predicateOrItems) {\n                await this.delete(label, item);\n            }\n        }\n        else {\n            // Delete by predicate\n            const items = await this.all(label);\n            for (const item of items) {\n                if (predicateOrItems(item)) {\n                    await this.delete(label, item);\n                }\n            }\n        }\n    }\n    /**\n     * Retrieves an entity of type `T` by its unique identifier (UUID) from the storage.\n     *\n     * @template T - The type of the entity that extends `EntityBase`.\n     * @param label - A string representing the label or category of the entity.\n     * @param uuid - The unique identifier of the entity to retrieve.\n     * @returns A promise that resolves to the entity of type `T` if found, or `undefined` if not found.\n     */\n    async findById(label, uuid) {\n        const item = await this.provider.findById(label, uuid);\n        if (!item)\n            return undefined;\n        return this.parseItem(label, item);\n    }\n    /**\n     * Finds and retrieves items from the storage based on the specified label and query function.\n     * Optionally, specific keys can be picked from the retrieved items.\n     *\n     * @template T - The type of the entity being queried, extending `EntityBase`.\n     * @template K - The keys of the entity type `T` that can be picked, defaults to all keys of `T`.\n     *\n     * @param label - A string label used to identify the collection or group of items in the storage.\n     * @param query - A function that takes an item of type `T` and returns a boolean indicating\n     *                whether the item matches the query criteria.\n     * @param pickKeys - An optional array of keys of type `K` to specify which properties of the\n     *                   items should be included in the result. If not provided, all properties\n     *                   are included.\n     *\n     * @returns A promise that resolves to a `QueryableArray` containing the items of type `T`\n     *          that match the query, with only the specified keys if `pickKeys` is provided.\n     */\n    async find(label, query, pickKeys) {\n        const items = await this.provider.find(label, query, pickKeys);\n        return new QueryableArray_1.QueryableArray(...items.map(item => this.parseItem(label, item)));\n    }\n    /**\n     * Retrieves all entities of a specified type from the storage provider.\n     *\n     * @template T - The type of entities to retrieve, extending `EntityBase`.\n     * @param {Object} params - The parameters for the query.\n     * @param {string} params.label - The label identifying the type of entities to retrieve.\n     * @returns {Promise<Array<T>>} A promise that resolves to a `QueryableArray` containing the retrieved entities.\n     */\n    async all(label) {\n        try {\n            const items = await this.provider.all(label);\n            const parsedItems = items.map(item => {\n                const parsedItem = this.parseItem(label, item);\n                if (!parsedItem) {\n                    console.warn(`Failed to parse item for label ${label}:`, item);\n                    return null;\n                }\n                return parsedItem;\n            }).filter(item => item !== null);\n            return new QueryableArray_1.QueryableArray(...parsedItems);\n        }\n        catch (error) {\n            console.error(`Error retrieving all items for label ${label}:`, error);\n            return new QueryableArray_1.QueryableArray(); // Or throw an error, depending on your error-handling strategy\n        }\n    }\n    /**\n     * Converts an array of entities into a `QueryableArray`, enabling advanced querying capabilities.\n     *\n     * @template T - The type of entities in the array, extending `EntityBase`.\n     * @param items - The array of entities to be converted.\n     * @returns A `QueryableArray` containing the provided entities.\n     */\n    toQueryableArray(items) {\n        return new QueryableArray_1.QueryableArray(...items);\n    }\n    /**\n     * Initializes the offline storage provider with the specified storage name.\n     * This method ensures that the storage provider is ready for use.\n     *\n     * @returns A promise that resolves when the initialization is successful,\n     *          or rejects with an error if the initialization fails.\n     */\n    init() {\n        return new Promise(async (resolve, reject) => {\n            try {\n                await this.provider.init(this.storageName);\n                resolve();\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n}\nexports.OfflineStorage = OfflineStorage;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/OfflineStorage.js?");

/***/ }),

/***/ "./dist/src/storage/entity/PersistedEntity.js":
/*!****************************************************!*\
  !*** ./dist/src/storage/entity/PersistedEntity.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PersistedEntity = void 0;\nconst DefaultFormatter_1 = __webpack_require__(/*! ../formaters/DefaultFormatter */ \"./dist/src/storage/formaters/DefaultFormatter.js\");\nconst PersistedEntityBase_1 = __webpack_require__(/*! ./PersistedEntityBase */ \"./dist/src/storage/entity/PersistedEntityBase.js\");\n/**\n * An abstract base class that extends `PersistedEntityBase` to provide functionality for handling\n * offline entities with customizable formatting and parsing logic. This class is designed\n * to work with an optional entity definition (`IEntityDefinition`) that specifies how\n * properties of the entity should be formatted and parsed.\n *\n * @template T - The type of the entity that extends `PersistedEntityBase`.\n *\n * @extends PersistedEntityBase\n */\nclass PersistedEntity extends PersistedEntityBase_1.PersistedEntityBase {\n    entityDefinition;\n    constructor(builder) {\n        super();\n        this.entityDefinition = builder?.build();\n    }\n    /**\n     * Formats the value of a given key in the entity using a specific formatter.\n     * If a custom formatter is defined for the key in the entity definition, it will be used.\n     * Otherwise, a default formatter will be applied.\n     *\n     * @template K - The type of the key in the entity.\n     * @param key - The key of the entity whose value needs to be formatted.\n     * @param value - The value associated with the key to be formatted.\n     * @returns The formatted value.\n     */\n    format(key, value) {\n        if (this.entityDefinition && this.entityDefinition.formatters && this.entityDefinition.formatters[key]) {\n            return this.entityDefinition.formatters[key].format(value);\n        }\n        return new DefaultFormatter_1.DefaultFormatter().format(value);\n    }\n    /**\n     * Parses a given value using a formatter associated with the specified key.\n     * If a custom formatter is defined for the key in the entity definition, it will be used.\n     * Otherwise, a default formatter will be used to parse the value.\n     *\n     * @template K - A key of the generic type `T`.\n     * @param key - The key for which the value is being parsed.\n     * @param value - The value to be parsed.\n     * @returns The parsed value of type `T[K]`.\n     */\n    parse(key, value) {\n        if (this.entityDefinition && this.entityDefinition.formatters && this.entityDefinition.formatters[key]) {\n            return this.entityDefinition.formatters[key].parse(value);\n        }\n        return new DefaultFormatter_1.DefaultFormatter().parse(value);\n    }\n    /**\n     * Converts the current entity instance into a JSON representation.\n     *\n     * This method creates a partial copy of the entity, including all its properties.\n     * If the entity has a defined `entityDefinition` with custom formatters, it applies\n     * those formatters to the corresponding properties before including them in the JSON output.\n     *\n     * @returns A partial JSON representation of the entity with optional formatting applied.\n     */\n    toJSON() {\n        const json = { ...this };\n        if (this.entityDefinition && this.entityDefinition.formatters) {\n            for (const key in this.entityDefinition.formatters) {\n                if (this.hasOwnProperty(key)) {\n                    json[key] = this.format(key, this[key]);\n                }\n            }\n        }\n        return json;\n    }\n    /**\n     * Populates the current instance with values from a given JSON object.\n     *\n     * @template T - The type of the entity being populated.\n     * @param json - A partial JSON object containing the properties to populate.\n     *\n     * The method iterates over the keys in the provided JSON object and assigns\n     * values to the corresponding properties of the current instance if they exist.\n     *\n     * - If the `entityDefinition.formatters` is defined and contains a formatter for the key,\n     *   the value is parsed using the `parse` method before assignment.\n     * - If no formatter is defined, the value is directly assigned if it is not `undefined`.\n     *\n     * Type assertions are used to ensure compatibility between the JSON object and the\n     * instance properties.\n     */\n    fromJSON(json) {\n        for (const key in json) {\n            if (this.hasOwnProperty(key)) {\n                if (this.entityDefinition?.formatters && key in this.entityDefinition.formatters) {\n                    this[key] = this.parse(key, json[key]); // Type assertion\n                }\n                else {\n                    if (json[key] !== undefined) {\n                        this[key] = json[key]; // Type assertion\n                    }\n                }\n            }\n        }\n    }\n}\nexports.PersistedEntity = PersistedEntity;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/entity/PersistedEntity.js?");

/***/ }),

/***/ "./dist/src/storage/entity/PersistedEntityBase.js":
/*!********************************************************!*\
  !*** ./dist/src/storage/entity/PersistedEntityBase.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PersistedEntityBase = void 0;\n/**\n * Represents the base class for entities, providing common properties and functionality\n * for offline entities.\n *\n * @implements {IPersistedEntity }\n */\nclass PersistedEntityBase {\n    id;\n    created;\n    lastModified;\n    constructor() {\n        this.id = crypto.randomUUID();\n        this.created = Date.now();\n        this.lastModified = Date.now();\n    }\n}\nexports.PersistedEntityBase = PersistedEntityBase;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/entity/PersistedEntityBase.js?");

/***/ }),

/***/ "./dist/src/storage/entity/PersistedEntityBuilder.js":
/*!***********************************************************!*\
  !*** ./dist/src/storage/entity/PersistedEntityBuilder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PersistedEntityBuilder = void 0;\n/**\n * A generic builder class for managing and applying formatters to the properties of an entity.\n *\n * @template T - The type of the entity for which formatters are being managed.\n *\n * This class allows you to add formatters for specific keys of an entity and retrieve\n * the collection of formatters in a structured format. It is designed to facilitate\n * the customization of how individual properties of an entity are processed or displayed.\n *\n * Example usage:\n * ```typescript\n * interface User {\n *   name: string;\n *   age: number;\n * }\n *\n * const builder = new PersistedEntityBuilder<User>();\n * builder.addFormatter('name', new StringFormatter());\n * builder.addFormatter('age', new NumberFormatter());\n *\n * const result = builder.build();\n * console.log(result.formatters.name); // Outputs the formatter for 'name'\n * console.log(result.formatters.age);  // Outputs the formatter for 'age'\n * ```\n */\nclass PersistedEntityBuilder {\n    formatters = {};\n    /**\n     * Adds a formatter for a specific key in the entity.\n     *\n     * @template K - The type of the key in the entity.\n     * @param key - The key for which the formatter is being added.\n     * @param formatter - The formatter to process the value associated with the specified key.\n     * @returns The current instance of the builder for method chaining.\n     */\n    addFormatter(key, formatter) {\n        this.formatters[key] = formatter;\n        return this;\n    }\n    /**\n     * Builds and returns an object containing formatters for the properties of type `T`.\n     *\n     * @returns An object with a `formatters` property, where each key corresponds to a property\n     *          of type `T` and its value is an optional `IFormatter` for that property.\n     */\n    build() {\n        return { formatters: this.formatters };\n    }\n}\nexports.PersistedEntityBuilder = PersistedEntityBuilder;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/entity/PersistedEntityBuilder.js?");

/***/ }),

/***/ "./dist/src/storage/formaters/DefaultFormatter.js":
/*!********************************************************!*\
  !*** ./dist/src/storage/formaters/DefaultFormatter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DefaultFormatter = void 0;\nclass DefaultFormatter {\n    format(value) {\n        console.log('DefaultFormatter format', value);\n        return value;\n    }\n    parse(value) {\n        console.log('DefaultFormatter parse', value);\n        return value;\n    }\n}\nexports.DefaultFormatter = DefaultFormatter;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/formaters/DefaultFormatter.js?");

/***/ }),

/***/ "./dist/src/storage/interceptors/WebApiInterceptor.js":
/*!************************************************************!*\
  !*** ./dist/src/storage/interceptors/WebApiInterceptor.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebApiInterceptor = void 0;\nclass WebApiInterceptor {\n    config;\n    constructor(config) {\n        this.config = config;\n    }\n    /**\n     * Initializes the Web API interceptor with the specified database name.\n     *\n     * @param dbName - The name of the database to initialize the interceptor with.\n     * @returns A promise that resolves when the initialization is complete.\n     */\n    async init(dbName) {\n        console.log(`Http Provider initialized with base URL: ${this.config.baseUrl}`);\n    }\n    /**\n     * Makes an HTTP request to the specified URL using the Fetch API and returns the parsed JSON response.\n     *\n     * @template T - The expected type of the response data.\n     * @param url - The endpoint to which the request is sent, relative to the base URL.\n     * @param options - The configuration options for the fetch request, such as method, headers, and body.\n     * @returns A promise that resolves to the parsed JSON response of type `T`.\n     * @throws An error if the HTTP response status is not OK (status code outside the range 200-299).\n     */\n    async apiFetch(url, options) {\n        const response = await fetch(`${this.config.baseUrl}/${url}`, {\n            ...options,\n            headers: {\n                ...this.config.headers,\n                'Content-Type': 'application/json',\n            },\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return await response.json();\n    }\n    /**\n     * Updates an item in the specified collection by sending a PUT request to the API.\n     *\n     * @template T - The type of the item to be updated.\n     * @param collectionName - The name of the collection where the item resides.\n     * @param item - The item to be updated. It must include a `uuid` property to identify it.\n     * @returns A promise that resolves to the updated item of type `T`.\n     */\n    async update(collectionName, item) {\n        return await this.apiFetch(`${collectionName}/${item.uuid}`, {\n            method: 'PUT',\n            body: JSON.stringify(item),\n        });\n    }\n    /**\n     * Deletes an item from the specified collection in the web API.\n     *\n     * @template T - The type of the item to be deleted.\n     * @param collectionName - The name of the collection from which the item will be deleted.\n     * @param item - The item to be deleted. It is expected to have a `uuid` property.\n     * @returns A promise that resolves when the deletion is complete.\n     */\n    async delete(collectionName, item) {\n        await this.apiFetch(`${collectionName}/${item.uuid}`, {\n            method: 'DELETE',\n        });\n    }\n    /**\n     * Retrieves all items from the specified collection.\n     *\n     * @template T - The type of the items in the collection.\n     * @param collectionName - The name of the collection to fetch items from.\n     * @returns A promise that resolves to an array of items of type `T`.\n     */\n    async all(collectionName) {\n        return this.apiFetch(`${collectionName}`, {\n            method: 'GET',\n        });\n    }\n    /**\n     * Retrieves an item by its ID from the specified collection.\n     *\n     * @template T - The type of the item to be retrieved.\n     * @param {string} collectionName - The name of the collection to query.\n     * @param {number} id - The unique identifier of the item to retrieve.\n     * @returns {Promise<T | null>} A promise that resolves to the item if found, or `null` if not found.\n     */\n    async findById(collectionName, id) {\n        return await this.apiFetch(`${collectionName}/${id}`, {\n            method: 'GET',\n        });\n    }\n    async find(collectionName, query, pickKeys) {\n        throw \"Not yet implemented\";\n    }\n    /**\n     * Updates all items in the specified collection that match the given predicate.\n     *\n     * @template T - The type of the items in the collection.\n     * @param collectionName - The name of the collection to update.\n     * @param predicate - A function that determines whether an item should be updated.\n     *                     It takes an item of type `T` as input and returns a boolean.\n     * @param update - A function that applies the desired updates to an item.\n     *                 It takes an item of type `T` as input and modifies it in place.\n     * @returns A promise that resolves when the update operation is complete.\n     */\n    async updateAll(collectionName, predicate, update) {\n        await this.apiFetch(`${collectionName}/updateAll`, {\n            method: 'POST',\n            body: JSON.stringify({ predicate, update }),\n        });\n    }\n    /**\n     * Deletes multiple items from a specified collection in the storage.\n     *\n     * @template T - The type of the items in the collection.\n     * @param collectionName - The name of the collection from which items will be deleted.\n     * @param predicateOrItems - A predicate function to filter items for deletion or an array of items to delete.\n     *   - If a predicate function is provided, it will be applied to each item in the collection to determine if it should be deleted.\n     *   - If an array of items is provided, those specific items will be deleted.\n     * @returns A promise that resolves when the deletion operation is complete.\n     */\n    async deleteMany(collectionName, predicateOrItems) {\n        await this.apiFetch(`${collectionName}/deleteMany`, {\n            method: 'POST',\n            body: JSON.stringify({ predicateOrItems }),\n        });\n    }\n}\nexports.WebApiInterceptor = WebApiInterceptor;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interceptors/WebApiInterceptor.js?");

/***/ }),

/***/ "./dist/src/storage/interface/ICollection.js":
/*!***************************************************!*\
  !*** ./dist/src/storage/interface/ICollection.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/ICollection.js?");

/***/ }),

/***/ "./dist/src/storage/interface/ICollectionOperations.js":
/*!*************************************************************!*\
  !*** ./dist/src/storage/interface/ICollectionOperations.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/ICollectionOperations.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IEntityDefinition.js":
/*!*********************************************************!*\
  !*** ./dist/src/storage/interface/IEntityDefinition.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IEntityDefinition.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IFormatter.js":
/*!**************************************************!*\
  !*** ./dist/src/storage/interface/IFormatter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IFormatter.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IInterceptor.js":
/*!****************************************************!*\
  !*** ./dist/src/storage/interface/IInterceptor.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IInterceptor.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IOfflineStorageProvider.js":
/*!***************************************************************!*\
  !*** ./dist/src/storage/interface/IOfflineStorageProvider.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IOfflineStorageProvider.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IPersistedEntity .js":
/*!*********************************************************!*\
  !*** ./dist/src/storage/interface/IPersistedEntity .js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IPersistedEntity_.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IProviderConfig.js":
/*!*******************************************************!*\
  !*** ./dist/src/storage/interface/IProviderConfig.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IProviderConfig.js?");

/***/ }),

/***/ "./dist/src/storage/interface/IWebApiConfig.js":
/*!*****************************************************!*\
  !*** ./dist/src/storage/interface/IWebApiConfig.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/interface/IWebApiConfig.js?");

/***/ }),

/***/ "./dist/src/storage/providers/IndexDBProvider.js":
/*!*******************************************************!*\
  !*** ./dist/src/storage/providers/IndexDBProvider.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IndexedDBProvider = void 0;\nclass IndexedDBProvider {\n    dbPromise = null;\n    storageName;\n    version;\n    constructor(version = 1) {\n        this.version = version;\n    }\n    ['constructor'](config) {\n        throw new Error('Method not implemented.');\n    }\n    addCollection(label, collection) {\n        throw new Error('No need to add collections to IndexedDB provider');\n    }\n    async init(storageName) {\n        this.storageName = storageName;\n        this.dbPromise = this.openDatabase();\n        await this.dbPromise; // Ensure db is open before proceeding\n    }\n    openDatabase() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.storageName, this.version);\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                if (!db.objectStoreNames.contains('data')) {\n                    db.createObjectStore('data', { keyPath: 'id' });\n                }\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n            request.onerror = (event) => {\n                reject(event.target.error);\n            };\n        });\n    }\n    async getObjectStore(mode) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction('data', mode);\n        return transaction.objectStore('data');\n    }\n    async save() {\n        // IndexedDB handles saving automatically.\n    }\n    async update(label, item) {\n        const store = await this.getObjectStore('readwrite');\n        const data = await store.get(item.id);\n        if (data) {\n            await store.put(item);\n        }\n        else {\n            await store.add(item);\n        }\n    }\n    async delete(label, item) {\n        const store = await this.getObjectStore('readwrite');\n        await store.delete(item.id);\n    }\n    async findById(label, uuid) {\n        const store = await this.getObjectStore('readonly');\n        return new Promise((resolve, reject) => {\n            const request = store.get(uuid);\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(request.error);\n            };\n        });\n    }\n    async find(label, query, pickKeys) {\n        const store = await this.getObjectStore('readonly');\n        const allItems = await new Promise((resolve, reject) => {\n            const request = store.getAll();\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n        const filteredItems = allItems.filter(query);\n        if (pickKeys) {\n            return filteredItems.map((item) => {\n                const result = {};\n                pickKeys.forEach((key) => {\n                    if (key in item) {\n                        result[key] = item[key];\n                    }\n                });\n                return result;\n            });\n        }\n        else {\n            return filteredItems;\n        }\n    }\n    async all(label) {\n        const store = await this.getObjectStore('readonly');\n        return new Promise((resolve, reject) => {\n            const request = store.getAll();\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(request.error);\n            };\n        });\n    }\n    async getCollections() {\n        return Promise.resolve(new Map()); // IndexedDB does not support getting collections like LocalStorage\n    }\n}\nexports.IndexedDBProvider = IndexedDBProvider;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/providers/IndexDBProvider.js?");

/***/ }),

/***/ "./dist/src/storage/providers/LocalStorageProvider.js":
/*!************************************************************!*\
  !*** ./dist/src/storage/providers/LocalStorageProvider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocalStorageProvider = void 0;\nclass LocalStorageProvider {\n    ['constructor'](config) {\n        throw new Error('Method not implemented.');\n    }\n    /**\n     * Creates an instance of the LocalStorageProvider.\n     *\n     * @param config - Optional configuration object implementing the IProviderConfig interface.\n     *                 This can be used to customize the behavior of the provider.\n     */\n    constructor(config) {\n        console.log(\"\", config);\n    }\n    models = new Map();\n    storageName;\n    /**\n     * Initializes the local storage provider with the specified storage name.\n     * This method sets the storage name and attempts to deserialize any existing\n     * data associated with it.\n     *\n     * @param storageName - The name of the storage to initialize.\n     * @returns A promise that resolves when the initialization is complete.\n     */\n    async init(storageName) {\n        this.storageName = storageName;\n        await this.deSerialize();\n    }\n    /**\n     * Saves the current state of the storage provider to the browser's local storage.\n     *\n     * @returns A promise that resolves once the data has been successfully saved.\n     */\n    async save() {\n        return new Promise((resolve) => {\n            const data = this.serialize();\n            localStorage.setItem(this.storageName, data);\n            resolve();\n        });\n    }\n    /**\n     * Updates an existing item in the collection associated with the given label.\n     * If the item does not exist in the collection, it will be added.\n     * The `lastModified` property of the item is updated to the current timestamp.\n     *\n     * @template T - A type that extends `PersistedEntityBase`.\n     * @param label - The label identifying the collection to update.\n     * @param item - The item to update or add to the collection.\n     * @returns A promise that resolves when the update operation is complete.\n     */\n    async update(label, item) {\n        const model = this.models.get(label);\n        if (model) {\n            const index = model.collection.findIndex((pre) => pre.id === item.id);\n            if (index !== -1) {\n                item.lastModified = Date.now();\n                model.collection[index] = item;\n            }\n            else {\n                model.collection.push(item);\n            }\n        }\n        await this.save();\n    }\n    /**\n     * Deletes an item from the specified collection in local storage.\n     *\n     * @template T - The type of the entity that extends `PersistedEntityBase`.\n     * @param label - The label identifying the collection to delete the item from.\n     * @param item - The item to be deleted, identified by its `id` property.\n     * @returns A promise that resolves when the item has been removed and the changes are saved.\n     */\n    async delete(label, item) {\n        const model = this.models.get(label);\n        if (model) {\n            const index = model.collection.findIndex((pre) => pre.id === item.id);\n            if (index !== -1) {\n                model.collection.splice(index, 1);\n            }\n        }\n        await this.save();\n    }\n    /**\n     * Retrieves an entity of type `T` from the specified collection by its unique identifier.\n     *\n     * @template T - The type of the entity, extending `PersistedEntityBase`.\n     * @param label - The label identifying the collection to search in.\n     * @param uuid - The unique identifier of the entity to find.\n     * @returns A promise that resolves to the entity of type `T` if found, or `undefined` if not found.\n     */\n    async findById(label, uuid) {\n        const model = this.models.get(label);\n        if (model) {\n            return model.collection.find((pre) => pre.id === uuid);\n        }\n        return undefined;\n    }\n    /**\n     * Finds and retrieves items from a specified model based on a query function.\n     * Optionally, specific keys can be picked from the matched items.\n     *\n     * @template T - The type of the persisted entity.\n     * @template K - The keys of the entity to pick (defaults to all keys of T).\n     * @param label - The label identifying the model to search within.\n     * @param query - A function used to filter items in the model's collection.\n     * @param pickKeys - An optional array of keys to pick from the matched items.\n     * @returns A promise that resolves to an array of items matching the query,\n     *          with only the specified keys if `pickKeys` is provided.\n     */\n    async find(label, query, pickKeys) {\n        const model = this.models.get(label);\n        if (!model) {\n            return [];\n        }\n        const filteredItems = model.collection.filter(query);\n        if (pickKeys) {\n            return filteredItems.map((item) => {\n                const result = {};\n                pickKeys.forEach((key) => {\n                    if (key in item) {\n                        result[key] = item[key];\n                    }\n                });\n                return result;\n            });\n        }\n        else {\n            return filteredItems;\n        }\n    }\n    /**\n     * Retrieves all entities of a specified type from the local storage provider.\n     *\n     * @template T - The type of the entities, extending `PersistedEntityBase`.\n     * @param label - The label identifying the collection of entities to retrieve.\n     * @returns A promise that resolves to an array of entities of type `T`.\n     *          If the label does not exist, an empty array is returned.\n     */\n    async all(label) {\n        const model = this.models.get(label);\n        if (model) {\n            return model.collection;\n        }\n        return [];\n    }\n    /**\n     * Retrieves all collections stored in the local storage provider.\n     *\n     * @returns {Promise<Map<string, any>>} A promise that resolves to a map containing the collections,\n     * where the keys are collection names and the values are the corresponding data.\n     */\n    async getCollections() {\n        return Promise.resolve(this.models);\n    }\n    /**\n     * Adds a new collection to the local storage provider.\n     *\n     * @template T - The type of the persisted entity, extending `PersistedEntityBase`.\n     * @param label - The unique label used to identify the collection.\n     * @param model - The model representing the structure of the collection.\n     * @returns void\n     */\n    addCollection(label, model) {\n        this.models.set(label, model);\n    }\n    serialize() {\n        return JSON.stringify(Array.from(this.models.entries()));\n    }\n    async deSerialize() {\n        return new Promise((resolve, reject) => {\n            const data = localStorage.getItem(this.storageName);\n            if (!data) {\n                reject(new Error('No data found'));\n                return;\n            }\n            try {\n                const parsedData = JSON.parse(data);\n                this.models = new Map(parsedData);\n                resolve();\n            }\n            catch (e) {\n                reject(new Error('Error parsing data'));\n            }\n        });\n    }\n}\nexports.LocalStorageProvider = LocalStorageProvider;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/providers/LocalStorageProvider.js?");

/***/ }),

/***/ "./dist/src/storage/utils/QueryableArray.js":
/*!**************************************************!*\
  !*** ./dist/src/storage/utils/QueryableArray.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueryableArray = void 0;\n/**\n * A custom array class that provides additional query-like methods for filtering, mapping, and manipulating arrays.\n * @template T - The type of elements in the array.\n */\nclass QueryableArray extends Array {\n    /**\n     * Skips the specified number of elements and returns the remaining elements.\n     * @param count - The number of elements to skip.\n     * @returns A new QueryableArray containing the remaining elements.\n     */\n    skip(count) {\n        const result = new QueryableArray(...this.slice(count));\n        return result;\n    }\n    /**\n     * Takes the specified number of elements from the start of the array.\n     * @param count - The number of elements to take.\n     * @returns A new QueryableArray containing the taken elements.\n     */\n    take(count) {\n        const result = new QueryableArray(...this.slice(0, count));\n        return result;\n    }\n    /**\n     * Filters the array based on a predicate function.\n     * @param predicate - A function to test each element.\n     * @returns A new QueryableArray containing the elements that satisfy the predicate.\n     */\n    where(predicate) {\n        const result = new QueryableArray(...this.filter(predicate));\n        return result;\n    }\n    /**\n     * Projects each element of the array into a new form.\n     * @template U - The type of the projected elements.\n     * @param selector - A function to transform each element.\n     * @returns A new QueryableArray containing the transformed elements.\n     */\n    select(selector) {\n        const result = new QueryableArray(...this.map(selector));\n        return result;\n    }\n    /**\n     * Returns the first element that satisfies the predicate or the first element if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The first matching element.\n     * @throws An error if no matching element is found.\n     */\n    first(predicate) {\n        const item = predicate ? this.find(predicate) : this[0];\n        if (item === undefined) {\n            throw new Error('Sequence contains no matching element');\n        }\n        return item;\n    }\n    /**\n     * Returns the first element that satisfies the predicate or undefined if no matching element is found.\n     * @param predicate - A function to test each element (optional).\n     * @returns The first matching element or undefined.\n     */\n    firstOrDefault(predicate) {\n        return predicate ? this.find(predicate) : this[0];\n    }\n    /**\n     * Returns the last element that satisfies the predicate or the last element if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The last matching element.\n     * @throws An error if no matching element is found.\n     */\n    last(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        if (items.length === 0) {\n            throw new Error('Sequence contains no matching element');\n        }\n        return items[items.length - 1];\n    }\n    /**\n     * Returns the last element that satisfies the predicate or undefined if no matching element is found.\n     * @param predicate - A function to test each element (optional).\n     * @returns The last matching element or undefined.\n     */\n    lastOrDefault(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        return items.length > 0 ? items[items.length - 1] : undefined;\n    }\n    /**\n     * Returns the only element that satisfies the predicate or the only element if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The single matching element.\n     * @throws An error if there is not exactly one matching element.\n     */\n    single(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        if (items.length !== 1) {\n            throw new Error('Sequence contains more than one matching element');\n        }\n        return items[0];\n    }\n    /**\n     * Returns the only element that satisfies the predicate or undefined if no matching element is found.\n     * @param predicate - A function to test each element (optional).\n     * @returns The single matching element or undefined.\n     */\n    singleOrDefault(predicate) {\n        const items = predicate ? this.filter(predicate) : this;\n        return items.length === 1 ? items[0] : undefined;\n    }\n    /**\n     * Determines whether any elements satisfy the predicate or whether the array contains any elements if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns True if any elements satisfy the predicate or if the array contains any elements.\n     */\n    any(predicate) {\n        return predicate ? this.some(predicate) : this.length > 0;\n    }\n    /**\n     * Determines whether all elements satisfy the predicate.\n     * @param predicate - A function to test each element.\n     * @returns True if all elements satisfy the predicate.\n     */\n    all(predicate) {\n        return this.every(predicate);\n    }\n    /**\n     * Counts the number of elements that satisfy the predicate or the total number of elements if no predicate is provided.\n     * @param predicate - A function to test each element (optional).\n     * @returns The count of matching elements.\n     */\n    count(predicate) {\n        return predicate ? this.filter(predicate).length : this.length;\n    }\n    /**\n     * Sorts the elements in ascending order based on a key.\n     * @template K - The type of the key.\n     * @param keySelector - A function to extract the key for each element.\n     * @returns A new QueryableArray containing the sorted elements.\n     */\n    orderBy(keySelector) {\n        const result = new QueryableArray(...this.sort((a, b) => {\n            if (keySelector(a) < keySelector(b))\n                return -1;\n            if (keySelector(a) > keySelector(b))\n                return 1;\n            return 0;\n        }));\n        return result;\n    }\n    /**\n     * Sorts the elements in descending order based on a key.\n     * @template K - The type of the key.\n     * @param keySelector - A function to extract the key for each element.\n     * @returns A new QueryableArray containing the sorted elements.\n     */\n    orderByDescending(keySelector) {\n        const result = new QueryableArray(...this.sort((a, b) => {\n            if (keySelector(a) > keySelector(b))\n                return -1;\n            if (keySelector(a) < keySelector(b))\n                return 1;\n            return 0;\n        }));\n        return result;\n    }\n    /**\n     * Groups the elements of the array based on a key.\n     * @template K - The type of the key.\n     * @param keySelector - A function to extract the key for each element.\n     * @returns A Map where the keys are the group keys and the values are QueryableArrays of grouped elements.\n     */\n    groupBy(keySelector) {\n        const map = new Map();\n        this.forEach(item => {\n            const key = keySelector(item);\n            if (!map.has(key)) {\n                map.set(key, new QueryableArray());\n            }\n            map.get(key).push(item);\n        });\n        return map;\n    }\n    /**\n     * Removes duplicate elements from the array.\n     * @returns A new QueryableArray containing only distinct elements.\n     */\n    distinct() {\n        const set = new Set(this);\n        return new QueryableArray(...set);\n    }\n}\nexports.QueryableArray = QueryableArray;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/src/storage/utils/QueryableArray.js?");

/***/ }),

/***/ "./dist/test/fake-api/ExtendedDish.js":
/*!********************************************!*\
  !*** ./dist/test/fake-api/ExtendedDish.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExtendedDish = void 0;\nconst index_1 = __webpack_require__(/*! ../../src/index */ \"./dist/src/index.js\");\nclass ExtendedDish extends index_1.PersistedEntity {\n    created;\n    lastModified;\n    constructor() {\n        super();\n        this.created = Date.now();\n        this.lastModified = Date.now();\n    }\n    categoryName;\n    category;\n    title;\n    price;\n    sku;\n    description;\n    uuid;\n    showInLimied;\n}\nexports.ExtendedDish = ExtendedDish;\n\n\n//# sourceURL=webpack://jolly-donny/./dist/test/fake-api/ExtendedDish.js?");

/***/ }),

/***/ "./dist/test/test.js":
/*!***************************!*\
  !*** ./dist/test/test.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TestClint = void 0;\nconst index_1 = __webpack_require__(/*! ../src/index */ \"./dist/src/index.js\");\nconst ExtendedDish_1 = __webpack_require__(/*! ./fake-api/ExtendedDish */ \"./dist/test/fake-api/ExtendedDish.js\");\nconst logger = (data) => {\n    const p = document.createElement(\"p\");\n    p.textContent = JSON.stringify(data);\n    document.querySelector(\"#output\")?.prepend(p);\n};\nclass TestClint {\n    storage;\n    async runCommands() {\n        const extendedDishes = await index_1.OfflineStorage.fetch('api/menu/', (result) => {\n            const dishes = new index_1.QueryableArray(...result.dishes);\n            const categories = new index_1.QueryableArray(...result.categories);\n            const extendedDishes = dishes.map((dish) => {\n                const category = categories.find((cat) => cat.id === dish.category);\n                const extendedDish = new ExtendedDish_1.ExtendedDish();\n                Object.assign(extendedDish, dish);\n                extendedDish.categoryName = category ? category.name : 'Unknown';\n                return extendedDish;\n            });\n            return extendedDishes;\n        });\n        extendedDishes.forEach(async (dish) => {\n            const existingDish = await this.storage.find('dishStorage', (d) => d.uuid === dish.uuid);\n            if (existingDish.length == 0) {\n                await this.storage.insert('dishStorage', dish);\n            }\n        });\n        const collection = await this.storage.getCollection('dishStorage').toArray();\n        collection.forEach(item => {\n            logger(item);\n        });\n    }\n    constructor() {\n        const providerConfig = {\n            interceptor: new index_1.WebApiInterceptor({\n                baseUrl: \"/api/\"\n            })\n        };\n        const provider = new index_1.LocalStorageProvider(providerConfig);\n        //const provider = new IndexedDBProvider\n        this.storage = new index_1.OfflineStorage(provider, 'dishStorage');\n        this.storage.init().then(async () => {\n            logger('Storage initialized');\n            await this.runCommands();\n        }).catch(async () => {\n            console.log('Storage initialization failed, creating new storage');\n            this.storage.addCollection('dishStorage');\n            this.storage.save();\n            await this.runCommands();\n        });\n    }\n}\nexports.TestClint = TestClint;\ndocument.addEventListener('DOMContentLoaded', () => {\n    const testApp = new TestClint();\n});\n\n\n//# sourceURL=webpack://jolly-donny/./dist/test/test.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/test/test.js");
/******/ 	
/******/ })()
;